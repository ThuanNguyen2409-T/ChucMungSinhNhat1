<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ch√∫c m·ª´ng sinh nh·∫≠t (Particles) - adaptive</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <style>
    html,body{ margin:0; height:100%; background:#380738; overflow:hidden; }
    canvas{ display:block; width:100vw; height:100vh; background:#380738; }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
// canvas ch√≠nh + canvas ·∫©n
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const offCanvas = document.createElement('canvas');
const offCtx = offCanvas.getContext('2d');

// c·∫•u h√¨nh ban ƒë·∫ßu (c√≥ th·ªÉ thay)
const FINAL_TEXT = 'Ch√∫c b√† c√≥ 1\nsinh nh·∫≠t th·∫≠t vui v·∫ª nha üéâ';
const SEQ = [
  { text: '3', duration: 900 },
  { text: '2', duration: 900 },
  { text: '1', duration: 900 },
  { text: FINAL_TEXT, duration: 3500 }
];

// tr·∫°ng th√°i v√† tham s·ªë linh ho·∫°t
let DPR = Math.max(window.devicePixelRatio || 1, 1);
let cssW = window.innerWidth;
let cssH = window.innerHeight;

// tham s·ªë m·∫∑c ƒë·ªãnh (s·∫Ω override d·ª±a tr√™n ƒëo hi·ªáu nƒÉng)
let GAP_DESKTOP = 6;
let GAP_MOBILE = 4;
let MIN_GAP = 2;
let baseGap = cssW < 600 ? GAP_MOBILE : GAP_DESKTOP;
let baseR = cssW < 600 ? 1.6 : 2.0;

// cap m·∫∑c ƒë·ªãnh (s·∫Ω ƒëi·ªÅu ch·ªânh)
let MAX_PARTICLES = 5000;     // m·∫∑c ƒë·ªãnh, s·∫Ω gi·∫£m n·∫øu m√°y y·∫øu
let ENABLE_SHADOW = true;     // t·∫Øt shadow ƒë·ªÉ tƒÉng fps tr√™n thi·∫øt b·ªã y·∫øu

// pool h·∫°t
let particles = [];
let currentText = null;

// resize & scale
function resizeAll(){
  DPR = Math.max(window.devicePixelRatio || 1, 1);
  cssW = window.innerWidth;
  cssH = window.innerHeight;

  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  canvas.width = Math.round(cssW * DPR);
  canvas.height = Math.round(cssH * DPR);

  offCanvas.width = canvas.width;
  offCanvas.height = canvas.height;

  ctx.setTransform(DPR,0,0,DPR,0,0);
  offCtx.setTransform(DPR,0,0,DPR,0,0);

  baseGap = cssW < 600 ? GAP_MOBILE : GAP_DESKTOP;
  baseR = cssW < 600 ? 1.6 : 2.0;

  // n·∫øu ƒëang hi·ªÉn th·ªã text, t√°i t·∫°o targets cho text hi·ªán t·∫°i
  if (currentText !== null) drawTextParticles(currentText);
}
window.addEventListener('resize', ()=> resizeAll());
window.addEventListener('orientationchange', ()=> setTimeout(resizeAll, 60));
resizeAll();

// l·ªõp Particle gi·ªëng c·∫•u tr√∫c b·∫°n
class Particle {
  constructor(x = Math.random()*cssW, y = Math.random()*cssH){
    this.x = x;
    this.y = y;
    this.tx = x; this.ty = y;
    this.r = baseR;
    this.hue = Math.random() * 360;
  }
  update(){
    const ease = 0.09;
    const osc = cssW < 600 ? 0.07 : 0.12;
    this.x += (this.tx - this.x)*ease + osc*Math.sin((Date.now()*0.0013)+this.x);
    this.y += (this.ty - this.y)*ease + osc*Math.cos((Date.now()*0.0013)+this.y);
    this.hue = (this.hue + 0.8) % 360;
  }
  draw(){
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
    ctx.fillStyle = `hsl(${this.hue},85%,60%)`;
    if (ENABLE_SHADOW) {
      ctx.shadowColor = 'rgba(255,255,255,0.14)';
      ctx.shadowBlur = 6;
    }
    ctx.fill();
    if (ENABLE_SHADOW) ctx.shadowBlur = 0;
  }
}

// H√†m l·∫•y targets t·ª´ text (sampling) - v·∫´n scale ƒë√∫ng DPR
function getTargetsFromText(text, desiredMax){
  const cssWidth = offCanvas.width / DPR;
  const cssHeight = offCanvas.height / DPR;

  // font size adaptive
  const lines = text.split('\n');
  let fontSize = Math.floor(Math.min(cssWidth, cssHeight) / Math.max(4, text.length/3));
  fontSize = Math.max(fontSize, 10);

  // start gap, s·∫Ω gi·∫£m n·∫øu thi·∫øu ƒëi·ªÉm
  let gapCandidate = baseGap;
  let targets = [];

  // l·∫∑p: sample v·ªõi gapCandidate, n·∫øu qu√° √≠t target => gi·∫£m gapCandidate (tƒÉng chi ti·∫øt)
  while(true){
    offCtx.clearRect(0,0, offCanvas.width, offCanvas.height);
    offCtx.fillStyle = '#fff';
    offCtx.textAlign = 'center';
    offCtx.textBaseline = 'middle';
    offCtx.font = `${fontSize}px Poppins`;
    const lineH = fontSize * 1.12;
    const startY = cssHeight/2 - ((lines.length - 1) * lineH / 2);
    for (let i=0;i<lines.length;i++){
      offCtx.fillText(lines[i], cssWidth/2, startY + i*lineH);
    }

    const img = offCtx.getImageData(0,0, offCanvas.width, offCanvas.height).data;
    targets = [];
    // sample theo CSS coords, map to device pixel index
    for (let y = 0; y < cssHeight; y += gapCandidate){
      for (let x = 0; x < cssWidth; x += gapCandidate){
        const xi = Math.floor(x * DPR);
        const yi = Math.floor(y * DPR);
        const idx = (yi * offCanvas.width + xi) * 4;
        if (img[idx + 3] > 128) targets.push({ x:x, y:y });
      }
    }

    // d·ª´ng khi ƒë·∫°t ƒë·ªß ho·∫∑c gap ƒë√£ nh·ªè nh·∫•t
    if (targets.length >= Math.max(120, desiredMax/3) || gapCandidate <= MIN_GAP) break;
    gapCandidate = Math.max(MIN_GAP, Math.floor(gapCandidate * 0.65));
  }

  // n·∫øu targets v·∫´n √≠t (v√≠ d·ª• tr√™n mobile), b·ªï sung t·ª´ opaque pixels (chi ti·∫øt cao h∆°n)
  if (targets.length < Math.min(200, desiredMax/2)){
    const imgFull = offCtx.getImageData(0,0, offCanvas.width, offCanvas.height).data;
    const opaque = [];
    for (let yi=0; yi < offCanvas.height; yi++){
      for (let xi=0; xi < offCanvas.width; xi++){
        const idx = (yi * offCanvas.width + xi) * 4;
        if (imgFull[idx + 3] > 128) opaque.push({ xi, yi });
      }
    }
    // mu·ªën th√™m ƒë·∫øn desiredMax
    const need = Math.min(desiredMax, Math.floor((cssWidth * cssHeight) / (baseGap * baseGap)));
    const toAdd = Math.max(0, need - targets.length);
    for (let k=0; k<toAdd && opaque.length>0; k++){
      const r = Math.floor(Math.random() * opaque.length);
      const p = opaque[r];
      const xCss = Math.max(0, Math.min(cssWidth-1, p.xi / DPR + (Math.random()-0.5)*baseGap*0.6));
      const yCss = Math.max(0, Math.min(cssHeight-1, p.yi / DPR + (Math.random()-0.5)*baseGap*0.6));
      targets.push({ x: xCss, y: yCss });
    }
  }

  // c·∫Øt targets n·∫øu v∆∞·ª£t desiredMax
  if (targets.length > desiredMax) targets = targets.slice(0, desiredMax);
  return targets;
}

// √Ånh x·∫° targets -> particles, t·∫°o l∆∞·ª£ng particle v·ª´a ph·∫£i
function applyTargets(targets){
  const needed = Math.min(targets.length, MAX_PARTICLES);
  if (particles.length < needed){
    const create = needed - particles.length;
    for (let i=0;i<create;i++){
      particles.push(new Particle(Math.random()*cssW, Math.random()*cssH));
    }
  }
  // g√°n target (kh√¥ng shuffle n·∫∑ng ƒë·ªÉ ti·∫øt ki·ªám)
  for (let i=0;i<particles.length;i++){
    if (i < targets.length){
      particles[i].tx = targets[i].x;
      particles[i].ty = targets[i].y;
      particles[i].r = baseR;
    } else {
      particles[i].tx = Math.random()*cssW;
      particles[i].ty = Math.random()*cssH;
      particles[i].r = baseR*0.9;
    }
  }
}

// h√†m ch√≠nh v·∫Ω text b·∫±ng h·∫°t (v·ªõi desiredMax = m·ª©c t·ªëi ƒëa mong mu·ªën cho ch·ªØ ƒë√≥)
function drawTextParticles(text, desiredMax){
  currentText = text;
  // getTargetsFromText t·ª± ƒë·∫£m b·∫£o sampling ph√π h·ª£p
  const targets = getTargetsFromText(text, desiredMax);
  applyTargets(targets);
}

// animate loop
let last = performance.now();
function animate(now){
  const dt = now - last; last = now;
  ctx.fillStyle = '#380738';
  ctx.fillRect(0,0, cssW, cssH);
  for (let p of particles){
    p.update();
    p.draw();
  }
  requestAnimationFrame(animate);
}

// helper: ƒëo kh·∫£ nƒÉng (hardwareConcurrency + ƒëo FPS trong 500ms)
async function detectCapability(){
  // 1) cores
  const cores = navigator.hardwareConcurrency || 2;
  // basic heuristic by cores & mobile
  const isMobile = /Mobi|Android|iPhone|iPad/.test(navigator.userAgent);
  // set baseline
  if (isMobile){
    MAX_PARTICLES = Math.max(2000, Math.min(5000, cores * 800)); // mobile -> 1600~4000
    baseGap = GAP_MOBILE;
    ENABLE_SHADOW = false;
  } else {
    MAX_PARTICLES = Math.max(4000, Math.min(9000, cores * 1500)); // desktop
    baseGap = GAP_DESKTOP;
    ENABLE_SHADOW = true;
  }

  // 2) ƒëo FPS th·ª±c t·∫ø trong 600ms (kh·ªüi ƒë·ªông nh·∫π)
  const measureMs = 600;
  let frames = 0;
  let t0 = performance.now();
  await new Promise(res => {
    function step(t){
      frames++;
      if (t - t0 < measureMs) requestAnimationFrame(step);
      else res();
    }
    requestAnimationFrame(step);
  });
  const elapsed = performance.now() - t0;
  const fps = frames / (elapsed / 1000);

  // adjust based on fps
  if (fps < 20){
    // m√°y y·∫øu => gi·∫£m nhi·ªÅu
    MAX_PARTICLES = Math.max(1000, Math.floor(MAX_PARTICLES * 0.35));
    baseGap = Math.max(baseGap, 6);
    ENABLE_SHADOW = false;
  } else if (fps < 30){
    MAX_PARTICLES = Math.max(2000, Math.floor(MAX_PARTICLES * 0.6));
    baseGap = Math.max(baseGap, 5);
    ENABLE_SHADOW = false;
  } else if (fps < 45){
    MAX_PARTICLES = Math.max(3000, Math.floor(MAX_PARTICLES * 0.8));
    baseGap = Math.max(baseGap, 4);
    ENABLE_SHADOW = true;
  } else {
    // m√°y kh·ªèe
    MAX_PARTICLES = Math.min(MAX_PARTICLES, Math.floor(MAX_PARTICLES * 1));
    baseGap = Math.max(2, baseGap);
    ENABLE_SHADOW = true;
  }

  // log ƒë·ªÉ debug (b·ªè ho·∫∑c gi·ªØ)
  console.log('capability:', { cores, isMobile, fps: Math.round(fps), MAX_PARTICLES, baseGap, ENABLE_SHADOW });
}

// ch·∫°y sequence async
async function runSequence(seq){
  // detect capability tr∆∞·ªõc khi render ch·ªØ l·ªõn
  await detectCapability();

  for (let i=0;i<seq.length;i++){
    // desiredMax = t·ªâ l·ªá d·ª±a tr√™n MAX_PARTICLES v√† b∆∞·ªõc (s·ªë nh·ªè cho 3/2/1, l·ªõn cho final)
    const desiredMax = seq[i].text.length <= 2 ? Math.floor(Math.min(600, MAX_PARTICLES * 0.12)) : Math.floor(MAX_PARTICLES * 0.9);
    drawTextParticles(seq[i].text, desiredMax);
    // ƒë·ª£i duration
    await new Promise(r => setTimeout(r, seq[i].duration));
  }
}

// b·∫Øt ƒë·∫ßu
requestAnimationFrame(animate);

// khi load: hi·ªÉn th·ªã '3' r·ªìi ch·∫°y full sequence
window.addEventListener('load', ()=>{
  drawTextParticles('3', Math.floor(Math.min(400, MAX_PARTICLES * 0.12)));
  setTimeout(()=> runSequence(SEQ), 300);
});

// resize handler
window.addEventListener('resize', ()=> resizeAll());
</script>
</body>
</html>

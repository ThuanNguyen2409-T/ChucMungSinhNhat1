<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ch√∫c m·ª´ng sinh nh·∫≠t (Particles)</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <style>
    html,body { margin:0; height:100%; background:#380738; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; background:#380738; }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
// canvas ch√≠nh
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// canvas ·∫©n ƒë·ªÉ v·∫Ω text v√† l·∫•y pixel
const offCanvas = document.createElement('canvas');
const offCtx = offCanvas.getContext('2d');

// c·∫•u h√¨nh (c√≥ th·ªÉ ch·ªânh n·∫øu c·∫ßn)
const FINAL_TEXT = 'Ch√∫c b√† c√≥ 1\nsinh nh·∫≠t th·∫≠t vui v·∫ª nha üéâ'; // ƒë·ªïi l·ªùi ch√∫c ·ªü ƒë√¢y
const SEQ = [
  { text: '3', duration: 900 },
  { text: '2', duration: 900 },
  { text: '1', duration: 900 },
  { text: FINAL_TEXT, duration: 3800 }
];

// gi·ªõi h·∫°n hi·ªáu nƒÉng (nhi·ªÅu h·∫°t s·∫Ω n·∫∑ng tr√™n ƒëi·ªán tho·∫°i y·∫øu)
const MAX_PARTICLES = 9000; // kh√¥ng cho v∆∞·ª£t qu√° s·ªë n√†y
const START_GAP_DESKTOP = 6; // gap m·∫∑c ƒë·ªãnh desktop
const START_GAP_MOBILE = 4;  // gap m·∫∑c ƒë·ªãnh mobile
const MIN_GAP = 2;           // gap nh·ªè nh·∫•t khi c·∫ßn (m·ªãn nh·∫•t, n·∫∑ng nh·∫•t)

// tr·∫°ng th√°i
let DPR = Math.max(window.devicePixelRatio || 1, 1);
let cssW = window.innerWidth;
let cssH = window.innerHeight;
let baseGap = cssW < 600 ? START_GAP_MOBILE : START_GAP_DESKTOP;
let baseR = cssW < 600 ? 1.6 : 2.0;
let particles = [];
let currentText = null;

// c·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc v√† scale contexts ƒë√∫ng DPR
function resizeAll(){
  DPR = Math.max(window.devicePixelRatio || 1, 1);
  cssW = window.innerWidth;
  cssH = window.innerHeight;

  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  canvas.width = Math.round(cssW * DPR);
  canvas.height = Math.round(cssH * DPR);

  offCanvas.width = canvas.width;
  offCanvas.height = canvas.height;

  // scale contexts ƒë·ªÉ d√πng to·∫° ƒë·ªô CSS px trong v·∫Ω text v√† t√≠nh to√°n
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  offCtx.setTransform(DPR, 0, 0, DPR, 0, 0);

  // c·∫≠p nh·∫≠t gap v√† b√°n k√≠nh theo k√≠ch th∆∞·ªõc
  baseGap = cssW < 600 ? START_GAP_MOBILE : START_GAP_DESKTOP;
  baseR = cssW < 600 ? 1.6 : 2.0;

  // n·∫øu ƒëang c√≥ text, t√°i t·∫°o targets cho text hi·ªán t·∫°i
  if (currentText !== null) {
    drawTextParticles(currentText);
  }
}
window.addEventListener('resize', () => { resizeAll(); });
window.addEventListener('orientationchange', () => { setTimeout(resizeAll, 60); });
resizeAll();

// l·ªõp Particle gi·ªëng c·∫•u tr√∫c c·ªßa b·∫°n
class Particle {
  constructor(x = Math.random() * cssW, y = Math.random() * cssH) {
    this.x = x;
    this.y = y;
    this.tx = x;
    this.ty = y;
    this.r = baseR;
    this.hue = Math.random() * 360;
  }
  update() {
    const ease = 0.09; // ƒë·ªô m∆∞·ª£t khi ti·∫øn v·ªÅ target
    const osc = cssW < 600 ? 0.07 : 0.12; // dao ƒë·ªông nh·ªè cho ƒë·∫πp
    this.x += (this.tx - this.x) * ease + osc * Math.sin((Date.now() * 0.0013) + this.x);
    this.y += (this.ty - this.y) * ease + osc * Math.cos((Date.now() * 0.0013) + this.y);
    this.hue = (this.hue + 0.9) % 360;
  }
  draw() {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
    ctx.fillStyle = `hsl(${this.hue},85%,60%)`;
    ctx.shadowColor = 'rgba(255,255,255,0.16)';
    ctx.shadowBlur = 6;
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

// l·∫•y list target (CSS px) t·ª´ text
// ch√∫ √Ω: v·∫Ω text l√™n offCanvas (ƒë√£ scale), nh∆∞ng sample theo CSS px r·ªìi map sang device pixel index
function getTargetsFromText(text) {
  // chu k·ª≥: th·ª≠ v·ªõi gap start, n·∫øu target qu√° √≠t -> gi·∫£m gap v√† th·ª≠ l·∫°i, t·ªëi thi·ªÉu MIN_GAP
  const cssWidth = offCanvas.width / DPR;
  const cssHeight = offCanvas.height / DPR;

  // auto compute fontSize theo k√≠ch th∆∞·ªõc v√† ƒë·ªô d√†i text
  const lines = text.split('\n');
  let fontSize = Math.floor(Math.min(cssWidth, cssHeight) / Math.max(4, text.length / 3));
  fontSize = Math.max(fontSize, 10);

  // b·∫Øt ƒë·∫ßu v·ªõi gapCandidate = baseGap
  let gapCandidate = baseGap;
  let targets = [];

  while (true) {
    // clear v√† v·∫Ω text
    offCtx.clearRect(0, 0, offCanvas.width, offCanvas.height);
    offCtx.fillStyle = '#ffffff';
    offCtx.textAlign = 'center';
    offCtx.textBaseline = 'middle';
    offCtx.font = `${fontSize}px Poppins`;

    const lineH = fontSize * 1.12;
    const startY = cssHeight / 2 - ((lines.length - 1) * lineH / 2);

    for (let i = 0; i < lines.length; i++) {
      offCtx.fillText(lines[i], cssWidth / 2, startY + i * lineH);
    }

    // l·∫•y pixel data (device pixels)
    const img = offCtx.getImageData(0, 0, offCanvas.width, offCanvas.height).data;
    targets = [];

    // sample theo CSS coords, sau ƒë√≥ map sang device pixels ƒë·ªÉ truy xu·∫•t index
    for (let y = 0; y < cssHeight; y += gapCandidate) {
      for (let x = 0; x < cssWidth; x += gapCandidate) {
        const xi = Math.floor(x * DPR);
        const yi = Math.floor(y * DPR);
        const idx = (yi * offCanvas.width + xi) * 4;
        if (img[idx + 3] > 128) {
          targets.push({ x: x, y: y });
        }
      }
    }

    // ƒëi·ªÅu ki·ªán d·ª´ng:
    // - ƒë·ªß target (>= 120) OR gapCandidate ƒë√£ nh·ªè t·ªõi MIN_GAP
    if (targets.length >= 120 || gapCandidate <= MIN_GAP) break;
    // n·∫øu targets qu√° √≠t, gi·∫£m gapCandidate ƒë·ªÉ l·∫•y chi ti·∫øt h∆°n
    gapCandidate = Math.max(MIN_GAP, Math.floor(gapCandidate * 0.7));
  }

  // n·∫øu targets v·∫´n qu√° √≠t (vd: text qu√° nh·ªè), tƒÉng font size 1.25 l·∫ßn v√† sample th√™m 1 l·∫ßn
  if (targets.length < 60 && fontSize < Math.min(cssWidth, cssHeight) / 2) {
    fontSize = Math.floor(fontSize * 1.25);
    offCtx.clearRect(0, 0, offCanvas.width, offCanvas.height);
    offCtx.font = `${fontSize}px Poppins`;
    const lineH2 = fontSize * 1.12;
    const startY2 = cssHeight / 2 - ((lines.length - 1) * lineH2 / 2);
    for (let i = 0; i < lines.length; i++) {
      offCtx.fillText(lines[i], cssWidth / 2, startY2 + i * lineH2);
    }
    const img2 = offCtx.getImageData(0, 0, offCanvas.width, offCanvas.height).data;
    targets = [];
    for (let y = 0; y < cssHeight; y += Math.max(MIN_GAP, 2)) {
      for (let x = 0; x < cssWidth; x += Math.max(MIN_GAP, 2)) {
        const xi = Math.floor(x * DPR);
        const yi = Math.floor(y * DPR);
        const idx = (yi * offCanvas.width + xi) * 4;
        if (img2[idx + 3] > 128) {
          targets.push({ x: x, y: y });
        }
      }
    }
  }

  return targets;
}

// apply targets cho particle pool (kh√¥ng pop targets)
function applyTargets(targets) {
  // gi·ªõi h·∫°n t·ªëi ƒëa particle ƒë·ªÉ tr√°nh lag n·∫∑ng
  const needed = Math.min(targets.length, MAX_PARTICLES);
  if (particles.length < needed) {
    const toCreate = needed - particles.length;
    for (let i = 0; i < toCreate; i++) {
      particles.push(new Particle(Math.random() * cssW, Math.random() * cssH));
    }
  }
  // shuffle targets nh·∫π ƒë·ªÉ tr√°nh pattern l·∫∑p (visual)
  // (s·ª≠ d·ª•ng Fisher-Yates)
  for (let i = targets.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [targets[i], targets[j]] = [targets[j], targets[i]];
  }
  // g√°n target cho particle (ch·ªâ g√°n t·ªõi s·ªë particle hi·ªán c√≥)
  for (let i = 0; i < particles.length; i++) {
    if (i < targets.length) {
      particles[i].tx = targets[i].x;
      particles[i].ty = targets[i].y;
      particles[i].r = baseR;
    } else {
      // particle d∆∞ di chuy·ªÉn r·∫£i r√°c
      particles[i].tx = Math.random() * cssW;
      particles[i].ty = Math.random() * cssH;
      particles[i].r = baseR * 0.9;
    }
  }
}

// draw text b·∫±ng h·∫°t (c·∫≠p nh·∫≠t currentText)
function drawTextParticles(text) {
  currentText = text;
  const targets = getTargetsFromText(text);
  applyTargets(targets);
}

// animate loop
let lastTs = performance.now();
function animate(ts) {
  const dt = ts - lastTs; lastTs = ts;

  ctx.fillStyle = '#380738';
  ctx.fillRect(0, 0, cssW, cssH);

  for (let p of particles) {
    p.update();
    p.draw();
  }

  requestAnimationFrame(animate);
}

// run sequence async (ƒë·ªÉ d·ªÖ control chu·ªói)
async function runSequence(seq) {
  for (let i = 0; i < seq.length; i++) {
    drawTextParticles(seq[i].text);
    await sleep(seq[i].duration);
  }
}
function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }

// start
requestAnimationFrame(animate);

window.addEventListener('load', () => {
  // v·∫Ω s·ªë 3 tr∆∞·ªõc, delay nh·ªè r·ªìi ch·∫°y full sequence
  drawTextParticles('3');
  setTimeout(() => runSequence(SEQ), 300);
});

// resize handler: resizeAll s·∫Ω g·ªçi drawTextParticles(currentText)
window.addEventListener('resize', () => { resizeAll(); });
</script>
</body>
</html>
